// This file is part of the ACTS project.
//
// Copyright (C) 2016 CERN for the benefit of the ACTS project
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#pragma once

#include "Acts/Utilities/HashedString.hpp"

#include <cassert>
#include <cstdint>
#include <string>
#include <vector>

namespace ActsFatras {

/// Particle identifier that encodes additional event information.
///
/// The barcode has to fulfill two separate requirements: be able to act as
/// unique identifier for particles within an event and to encode details
/// on the event structure for fast lookup. Since we only care about tracking
/// here, we need to support two scenarios:
///
/// *   Identify which primary/secondary vertex particles belong to. No
///     information on intermediate/unstable/invisible particles needs to be
///     retained. This information is already available in the underlying
///     generator event and should not be duplicated.
/// *   If (visible) particles convert, decay, or interact with the detector,
///     we need to be able to identify the initial (primary) particle. Typical
///     examples are pion nuclear interactions or electron/gamma conversions.
///
/// The vertex information is encoded as two numbers that define the
/// primary and secondary vertex. The primary vertex must be non-zero.
/// Particles with a zero secondary vertex originate directly from the primary
/// vertex.
///
/// Within one vertex (primary+secondary) each particle is identified by
/// a particle, generation, and sub-particle number. Particles originating
/// from the vertex must have zero generation and zero sub-particle number;
/// a consequence is that only non-zero generation can have non-zero
/// sub-particle numbers. A non-zero generation indicates that the particle
/// is a descendant of the original particle, e.g. from interactions or decay,
/// while the sub-particle number identifies the descendant particle.
///
/// With this encoding, non-primary particles and their primary parent can
/// be easily identified at the expense of not storing the exact decay history.
///
/// A barcode with all elements set to zero (the default value) is an invalid
/// value that can be used e.g. to mark missing or unknown particles.
///
/// ## Example
///
/// A particle generated in a primary interaction might have the barcode
///
///     2|0|14|0|0 -> vertex=2 (primary), particle=14, generation=0, sub=0
///
/// A simulation module might generate an interaction and create two new
/// particles. These are descendants of the initial particle and the simulation
/// module can generate the new barcodes directly by increasing the
/// generation number and choosing sub-particle identifiers:
///
///     2|0|14|1|0 -> vertex=2 (primary), particle=14, generation=1, sub=0
///     2|0|14|1|1 -> vertex=2 (primary), particle=14, generation=1, sub=1
///
/// If these secondary particles generate further tertiary particles
/// the barcode would be e.g.
///
///     2|0|14|2|0 -> vertex=2 (primary), particle=14, generation=2, sub=0
///
/// ## Possible issues
///
/// The hierarchical nature of the barcode allows barcode creation without
/// a central service. Since the full history is not stored, generated barcodes
/// for higher-generation particles can overlap when generated by independent
/// interactions. Assuming an initial primary particle with barcode
///
///     3|4|5|0|0 -> particle=5
///
/// a first interaction might create a secondary particle by increasing the
/// generation number (without destroying the initial particle)
///
///     3|4|5|1|0 -> particle=5, generation+=1, first sub-particle
///
/// The initial particle gets simulated further and at another step a second
/// interaction also creates a new particle. Since it knows nothing about
/// the previously created particle (no central service), it will generate
///
///     3|4|5|1|0 -> particle=5, generation+=1, first sub-particle
///
/// which is identical to the previously create barcode. These cases can be
/// easily solved by renumbering the sub-particle identifier within each
/// generation to contain unique values. However, this can only be done when all
/// particles are known.
class Barcode {
 public:
  using ValueVtx = std::uint16_t;
  using ValuePart = std::uint32_t;
  using ValueGen = std::uint8_t;

  // Construct an invalid barcode with all levels set to zero.
  constexpr Barcode()
      : vertexPrimaryID(0u),
        vertexSecondaryID(0u),
        particleID(0u),
        generationID(0u),
        subParticleID(0u) {}
  // Construct a valid barcode.
  constexpr Barcode(ValueVtx pv, ValueVtx sv, ValuePart p, ValueGen g,
                    ValuePart sp = 0u)
      : vertexPrimaryID(pv),
        vertexSecondaryID(sv),
        particleID(p),
        generationID(g),
        subParticleID(sp) {}
  Barcode(const std::vector<std::uint32_t>& data) { setData(data); }
  // Construct a valid barcode for vertex.
  constexpr Barcode(ValueVtx pv, ValueVtx sv, ValueGen g)
      : vertexPrimaryID(pv),
        vertexSecondaryID(sv),
        particleID(0u),
        generationID(g),
        subParticleID(0u) {}

  Barcode(const Barcode&) = default;
  Barcode(Barcode&&) = default;
  Barcode& operator=(const Barcode&) = default;
  Barcode& operator=(Barcode&&) = default;

  friend constexpr bool operator<(Barcode lhs, Barcode rhs) {
    if (lhs.vertexPrimary() != rhs.vertexPrimary()) {
      return lhs.vertexPrimary() < rhs.vertexPrimary();
    }
    if (lhs.vertexSecondary() != rhs.vertexSecondary()) {
      return lhs.vertexSecondary() < rhs.vertexSecondary();
    }
    if (lhs.particle() != rhs.particle()) {
      return lhs.particle() < rhs.particle();
    }
    if (lhs.generation() != rhs.generation()) {
      return lhs.generation() < rhs.generation();
    }
    return lhs.subParticle() < rhs.subParticle();
  }

  friend constexpr bool operator==(Barcode lhs, Barcode rhs) {
    return lhs.vertexPrimary() == rhs.vertexPrimary() &&
           lhs.vertexSecondary() == rhs.vertexSecondary() &&
           lhs.particle() == rhs.particle() &&
           lhs.generation() == rhs.generation() &&
           lhs.subParticle() == rhs.subParticle();
  }

  /// Return the primary vertex identifier.
  constexpr ValueVtx vertexPrimary() const { return vertexPrimaryID; }
  /// Return the secondary vertex identifier.
  constexpr ValueVtx vertexSecondary() const { return vertexSecondaryID; }
  /// Return the particle identifier.
  constexpr ValuePart particle() const { return particleID; }
  /// Return the generation identifier.
  constexpr ValueGen generation() const { return generationID; }
  /// Return the sub-particle identifier.
  constexpr ValuePart subParticle() const { return subParticleID; }

  std::vector<std::uint32_t> getData() const {
    return {vertexPrimary(), vertexSecondary(), particle(), generation(),
            subParticle()};
  }
  void setData(const std::vector<std::uint32_t>& data) {
    assert(data.size() == 5 &&
           "Barcode requires data vector to have exactly 5 elements");

    vertexPrimaryID = data[0];
    vertexSecondaryID = data[1];
    particleID = data[2];
    generationID = data[3];
    subParticleID = data[4];
  }

  /// Set the primary vertex identifier.
  constexpr Barcode& setVertexPrimary(ValueVtx id) {
    vertexPrimaryID = id;
    return *this;
  }
  /// Set the secondary vertex identifier.
  constexpr Barcode& setVertexSecondary(ValueVtx id) {
    vertexSecondaryID = id;
    return *this;
  }
  /// Set the parent particle identifier.
  constexpr Barcode& setParticle(ValuePart id) {
    particleID = id;
    return *this;
  }
  /// Set the particle identifier.
  constexpr Barcode& setGeneration(ValueGen id) {
    generationID = id;
    return *this;
  }
  /// Set the process identifier.
  constexpr Barcode& setSubParticle(ValuePart id) {
    subParticleID = id;
    return *this;
  }

  /// Construct a new barcode representing a descendant particle.
  ///
  /// @param sub sub-particle index of the new barcode.
  Barcode makeDescendant(ValuePart sub = 0u) const {
    return Barcode(vertexPrimary(), vertexSecondary(), particle(),
                   generation() + 1, sub);
  }

  /// Reduce the barcode to the vertex identifier.
  constexpr Barcode vertexId() const {
    // The vertex is identified by primary vertex, secondary vertex, and
    // generation. The other components are set to 0 so two particle originating
    // from the same vertex will have the same vertex ID.
    return Barcode(vertexPrimary(), vertexSecondary(), generation());
  }

  /// Reduce the barcode to the particle identifier.
  constexpr Barcode withoutSubparticle() const {
    // Provide a pseudo-barcode that contains all fields but not the
    // subparticle counter. This can be used as key in a map to store the
    // subparticle information
    return Barcode(vertexPrimary(), vertexSecondary(), particle(),
                   generation());
  }

  friend inline std::ostream& operator<<(std::ostream& os, Barcode barcode) {
    // extra "+" to ensure printing as a number and not as a character
    os << "vp=" << +barcode.vertexPrimary()
       << "|vs=" << +barcode.vertexSecondary() << "|p=" << +barcode.particle()
       << "|g=" << +barcode.generation() << "|sp=" << +barcode.subParticle();
    return os;
  }

  Acts::HashedString hash() const {
    std::string str = std::to_string(vertexPrimary()) + "-" +
                      std::to_string(vertexSecondary()) + "-" +
                      std::to_string(particle()) + "-" +
                      std::to_string(generation()) + "-" +
                      std::to_string(subParticle());

    return Acts::hashStringDynamic(str);
  }

 private:
  ValueVtx vertexPrimaryID;
  ValueVtx vertexSecondaryID;
  ValuePart particleID;
  ValueGen generationID;
  ValuePart subParticleID;
};

}  // namespace ActsFatras

// specialize std::hash so Barcode can be used e.g. in an unordered_map
namespace std {
template <>
struct hash<ActsFatras::Barcode> {
  auto operator()(ActsFatras::Barcode barcode) const noexcept {
    return barcode.hash();
  }
};
}  // namespace std
