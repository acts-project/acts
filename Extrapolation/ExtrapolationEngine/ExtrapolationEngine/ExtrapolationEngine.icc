///////////////////////////////////////////////////////////////////
// ExtrapolationEngine.icc, ACTS project
///////////////////////////////////////////////////////////////////

// Geometry module
#include "Surfaces/Surface.h"
#include "Volumes/BoundarySurface.h"
#include "Detector/TrackingGeometry.h"
#include "Detector/TrackingVolume.h"
#include "Detector/Layer.h"
// STD
#include <iostream>
#include <iomanip>

template <class T> Acts::ExtrapolationCode Acts::ExtrapolationEngine::extrapolateT(Acts::ExtrapolationCell<T>& eCell,
                                                                                 const Acts::Surface* sf,
                                                                                 Acts::PropDirection dir,
                                                                                 const Acts::BoundaryCheck& bcheck) const
{

    EX_MSG_DEBUG(eCell.navigationStep, "extrapolate", "", "starting extrapolation sequence.");
    // initialize the navigation
    Acts::ExtrapolationCode eCode = initNavigation<T>(eCell,sf,dir);
    EX_MSG_VERBOSE(eCell.navigationStep, "extrapolate", "", "initialize navigation with return code : " << eCode.toString() );
    // main loop over volumes 
    while (eCell.leadVolume && eCode == Acts::ExtrapolationCode::InProgress ){
        // give output that you are in the master volume loop
        EX_MSG_VERBOSE(eCell.navigationStep, "extrapolate", "loop", "processing volume : " << eCell.leadVolume->volumeName() );
        // get the appropriate IExtrapolationEngine
        Acts::GeometryType geoType = eCell.leadVolume->geometrySignature()>2 ? Acts::Dense : Acts::Static;
        const Acts::IExtrapolationEngine* iee = m_eeAccessor[geoType];
        eCode = iee ? iee->extrapolate(eCell, sf, bcheck) : Acts::ExtrapolationCode::FailureConfiguration;
        // give a message about what you have
        EX_MSG_VERBOSE(eCell.navigationStep, "extrapolate", "", "returned from volume with return code : " << eCode.toString() <<
   	  " and geoType:"<< geoType );
    }
    EX_MSG_DEBUG(eCell.navigationStep, "extrapolate", "", "extrapolation finished with return code : " << eCode.toString() );
    // before you return, finalize: sets the leadParameters to endParameters and empties the garbage bin
    eCell.finalize(eCode);
    // return the code
    return eCode;
}
                                                          
                                                          
template <class T> Acts::ExtrapolationCode Acts::ExtrapolationEngine::initNavigation(Acts::ExtrapolationCell<T>& eCell,
                                                                                   const Acts::Surface* sf,
                                                                                   Acts::PropDirection dir) const throw (GaudiException)
{
    // initialize the Navigation stream ----------------------------------------------------------------------------------------
    //
    // this is the global initialization, it only associated direct objects
    // detailed navigation search needs to be done by the sub engines (since they know best)
    EX_MSG_DEBUG(++eCell.navigationStep, "navigation", "", "initialize the navigation stream.");
    // initialization of the navigation requires that leadParameters to be the startParameters
    eCell.leadParameters = eCell.startParameters;
    // now check the tracking geometry and retrieve it if not existing
    if (!m_trackingGeometry && updateTrackingGeometry().isFailure()){
	    EX_MSG_WARNING(eCell.navigationStep, "navigation", "", "could not retrieve geometry. Stopping.");
        // configuration error
        return Acts::ExtrapolationCode::FailureConfiguration;
    } else
      EX_MSG_VERBOSE(eCell.navigationStep, "navigation", "", "geometry ready to use.");
    // ---------- START initialization -----------------------------------------------------------------------------------------
    // initialize the start parameters - try association first
    eCell.startLayer  = eCell.startLayer ? eCell.startLayer : eCell.leadParameters->associatedSurface().associatedLayer();
    eCell.startVolume = eCell.startVolume ? eCell.startVolume : ( eCell.startLayer ? eCell.startLayer->enclosingTrackingVolume() : 0  );
    // check if you are at the volume boundary
    if (!eCell.startVolume ||  m_trackingGeometry->atVolumeBoundary(eCell.startParameters->position(),eCell.startVolume,0.001)  ) {
      Acts::ExtrapolationCode eVol = m_navigationEngine->resolvePosition(eCell,dir,true);  
      if (!eVol.isSuccessOrRecovered() && !eVol.inProgress()) return eVol; 
      eCell.startVolume = eCell.leadVolume;
    } else {
      eCell.leadVolume = eCell.startVolume;
    }
    // bail out of the start volume can not be resolved
    if (!eCell.startVolume) return Acts::ExtrapolationCode::FailureNavigation;
    // screen output
    EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "start volume termined as : " << eCell.startVolume->volumeName() );
    // check layer association
    eCell.startLayer     = eCell.startLayer ? eCell.startLayer : eCell.startVolume->associatedLayer(eCell.leadParameters->position());
    if (eCell.startLayer)
       EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "start layer termined with index : " << eCell.startLayer->geoID());
    eCell.setRadialDirection();
    // ---------- END initialization -----------------------------------------------------------------------------------------
    if (sf){
      // keep track of the end surface
      eCell.endSurface = sf;
      // re-evaluate the radial direction if the end surface is given
      // should not happen in FATRAS extrapolation mode
      if ( !eCell.checkConfigurationMode(Acts::ExtrapolationMode::FATRAS) )
           eCell.setRadialDirection();
           // trying association via the layer : associated layer of material layer
           eCell.endLayer  =  sf->associatedLayer();
           eCell.endVolume = eCell.endLayer ? eCell.endLayer->enclosingTrackingVolume() : 0;
      // check if you found layer and volume
      if (!eCell.endVolume){
          EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "end volume needs to be determinded by surface intersection." );
          // use a propagation to find the endVolume and endLayer
          // - @TODO can be opmisied (straiht line for high momentum - use directly )
          Acts::ExtrapolationCell<T> navCell(*eCell.leadParameters, dir);
          navCell.addConfigurationMode(Acts::ExtrapolationMode::Direct);
          // screen output
          m_propagationEngine->propagate(navCell,*eCell.endSurface,Acts::anyDirection,false, eCell.navigationCurvilinear);
          // check for sucess to the destination
          // CHECK_ECODE_SUCCESS_NODEST(navCell, eCode); @TODO check what this is
          // // screen output
          // EX_MSG_VERBOSE (eCell.navigationStep, "navigation", "", "found endVolume and andLayer through propagation - return code : " << eCode.toString() );
          // take the lead parameters to find end volume and end layer
	      // eCell.endVolume = trackingGeometry().lowestTrackingVolume(navCell.endParameters->position());
	      // eCell.endLayer  = trackingGeometry().associatedLayer(navCell.endParameters->position());
	      // memory cleanup
          delete navCell.endParameters;
      }
      // check the final end volume configuraiton - screen output
      if (eCell.endVolume)
          EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "end volume termined as : " << eCell.endVolume->volumeName());
      if (eCell.endLayer)
          EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "end layer termined with index : " << eCell.endLayer->geoID());
    } else
        EX_MSG_VERBOSE( eCell.navigationStep, "navigation", "", "no destination surface nor end volume provided, extrapolaiton has to stop on other means." );
    // return the progress call
    return Acts::ExtrapolationCode::InProgress;                                                              
}


